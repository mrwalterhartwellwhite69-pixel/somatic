{"version":3,"file":"submitQueue-G1WRLlPK.js","sources":["../../src/utils/submitQueue.js"],"sourcesContent":["// Enhanced submission queue with improved error handling and retry logic\nimport { logError } from '../utils/analytics';\n\nconst STORAGE_KEY = 'somatic:submissionQueue_v2';\nconst MAX_RETRIES = 10;\nconst MIN_BACKOFF = 1000; // 1 second\nconst MAX_BACKOFF = 300000; // 5 minutes\nconst MAX_QUEUE_SIZE = 100; // Prevent queue from growing too large\nconst MAX_PAYLOAD_SIZE = 1024 * 1024; // 1MB\nconst CLEANUP_INTERVAL = 24 * 60 * 60 * 1000; // 24 hours\n\n// HTTP status codes that indicate retryable errors\nconst RETRYABLE_STATUS_CODES = new Set([\n  408, // Request Timeout\n  429, // Too Many Requests\n  500, // Internal Server Error\n  502, // Bad Gateway\n  503, // Service Unavailable\n  504  // Gateway Timeout\n]);\n\nlet processorStarted = false;\nlet onlineStatus = navigator.onLine;\nconst subscribers = new Set();\n\n// Subscribe to queue status changes\nexport function subscribeToQueueStatus(callback) {\n  subscribers.add(callback);\n  return () => subscribers.delete(callback);\n}\n\nfunction notifySubscribers(status) {\n  subscribers.forEach(callback => {\n    try {\n      callback(status);\n    } catch (error) {\n      console.error('Error in queue subscriber:', error);\n    }\n  });\n}\n\n// Enhanced queue storage with error handling\nclass QueueStorage {\n  static read() {\n    try {\n      const raw = localStorage.getItem(STORAGE_KEY);\n      if (!raw) return [];\n      const data = JSON.parse(raw);\n      return Array.isArray(data) ? data : [];\n    } catch (error) {\n      logError('Error reading submission queue', { error });\n      return [];\n    }\n  }\n\n  static write(queue) {\n    try {\n      localStorage.setItem(STORAGE_KEY, JSON.stringify(queue));\n      notifySubscribers({ queueLength: queue.length });\n    } catch (error) {\n      logError('Error writing submission queue', { error });\n      // Try to clear some space\n      try {\n        const keys = Object.keys(localStorage);\n        if (keys.length > 10) {\n          keys.slice(0, 5).forEach(key => localStorage.removeItem(key));\n        }\n        localStorage.setItem(STORAGE_KEY, JSON.stringify(queue));\n      } catch (e) {\n        logError('Failed to make space in localStorage', { error: e });\n      }\n    }\n  }\n\n  static push(item) {\n    const queue = this.read();\n    \n    // Enforce queue size limit\n    if (queue.length >= MAX_QUEUE_SIZE) {\n      // Remove oldest items if queue is full\n      queue.splice(0, queue.length - MAX_QUEUE_SIZE + 1);\n      logError('Queue size limit reached, removing oldest items');\n    }\n\n    // Check payload size\n    const payloadSize = new TextEncoder().encode(JSON.stringify(item.payload)).length;\n    if (payloadSize > MAX_PAYLOAD_SIZE) {\n      logError('Payload size exceeds limit', { \n        size: payloadSize, \n        limit: MAX_PAYLOAD_SIZE,\n        id: item.id \n      });\n      throw new Error('Payload size exceeds limit');\n    }\n\n    queue.push(item);\n    this.write(queue);\n  }\n\n  static remove(id) {\n    const queue = this.read().filter(i => i.id !== id);\n    this.write(queue);\n  }\n\n  static update(id, updates) {\n    const queue = this.read();\n    const index = queue.findIndex(i => i.id === id);\n    if (index !== -1) {\n      queue[index] = { ...queue[index], ...updates };\n      this.write(queue);\n    }\n  }\n}\n\n// Calculate backoff time with jitter\nfunction calculateBackoff(attempts) {\n  const base = Math.min(MAX_BACKOFF, Math.pow(2, attempts) * MIN_BACKOFF);\n  const jitter = Math.random() * 0.3 * base; // 30% jitter\n  return Math.min(MAX_BACKOFF, base + jitter);\n}\n\n// Enhanced API endpoint detection\nfunction getApiEndpoint() {\n  const base = import.meta?.env?.VITE_API_BASE ||\n    process.env.VITE_API_BASE ||\n    window.__RUNTIME_CONFIG__?.API_BASE ||\n    '';\n    \n  const endpoint = base ? \n    `${base.replace(/\\/$/, '')}/api/log-visit` : \n    '/api/log-visit';\n\n  // Validate URL format\n  try {\n    new URL(endpoint, window.location.origin);\n    return endpoint;\n  } catch (error) {\n    logError('Invalid API endpoint', { endpoint, error });\n    return '/api/log-visit'; // Fallback to default\n  }\n}\n\n// Enhanced backend submission with timeout and retry handling\nasync function sendToBackend(payload, { timeout = 25000, retryAttempt = 0 } = {}) {\n  const endpoint = getApiEndpoint();\n  \n  try {\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), timeout);\n\n    const res = await fetch(endpoint, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'X-Retry-Attempt': retryAttempt.toString()\n      },\n      body: JSON.stringify(payload),\n      signal: controller.signal\n    });\n\n    clearTimeout(timeoutId);\n\n    if (!res.ok) {\n      const text = await res.text().catch(() => '');\n      throw new Error(`HTTP ${res.status}: ${text}`);\n    }\n\n    const data = await res.json().catch(() => ({}));\n    return { success: true, data };\n\n  } catch (error) {\n    const isTimeout = error.name === 'AbortError';\n    const isNetwork = !navigator.onLine || \n      error.message.includes('NetworkError') || \n      error.message.includes('Failed to fetch');\n    const isRetryableStatus = error.status && RETRYABLE_STATUS_CODES.has(error.status);\n    \n    // Check for connection/DNS issues\n    const isConnectionIssue = error.message.includes('ECONNREFUSED') || \n      error.message.includes('ENOTFOUND') ||\n      error.message.includes('getaddrinfo');\n    \n    // Check for CORS/TLS issues\n    const isSecurityIssue = error.message.includes('SSL') || \n      error.message.includes('TLS') ||\n      error.message.includes('CORS');\n\n    logError('Backend submission failed', { \n      error,\n      isTimeout,\n      isNetwork,\n      isRetryableStatus,\n      isConnectionIssue,\n      isSecurityIssue,\n      retryAttempt,\n      endpoint \n    });\n\n    return { \n      success: false, \n      retryable: isTimeout || isNetwork || isRetryableStatus || isConnectionIssue,\n      error \n    };\n  }\n}\n\n// Enhanced submission queuing with immediate attempt\nexport async function enqueueSubmission(payload) {\n  const id = `queued-${Date.now()}-${Math.random().toString(36).slice(2,9)}`;\n  \n  const envelope = {\n    id,\n    createdAt: new Date().toISOString(),\n    attempts: 0,\n    status: 'pending',\n    payload\n  };\n\n  // Try immediate submission\n  try {\n    const result = await sendToBackend(payload);\n    if (result.success) {\n      return { sent: true, data: result.data };\n    }\n    \n    // Queue for retry if retryable\n    if (result.retryable) {\n      QueueStorage.push(envelope);\n      startSubmissionQueue();\n      return { sent: false, queued: true, queuedId: id };\n    }\n\n    // Non-retryable error\n    throw result.error;\n\n  } catch (error) {\n    logError('Submission failed', { error, payload });\n    QueueStorage.push(envelope);\n    startSubmissionQueue();\n    return { sent: false, queued: true, queuedId: id, error };\n  }\n}\n\n// Enhanced queue processor with improved error handling\nasync function processQueueOnce() {\n  if (!navigator.onLine) return;\n\n  const queue = QueueStorage.read();\n  if (!queue.length) return;\n\n  for (const item of queue) {\n    try {\n      if (item.status === 'processing') continue;\n      if (item.attempts >= MAX_RETRIES) {\n        logError('Dropping item after max retries', { item });\n        QueueStorage.remove(item.id);\n        continue;\n      }\n\n      // Check backoff\n      const backoff = calculateBackoff(item.attempts);\n      if (item.lastAttempt && Date.now() - new Date(item.lastAttempt).getTime() < backoff) {\n        continue;\n      }\n\n      // Mark as processing\n      QueueStorage.update(item.id, { \n        status: 'processing',\n        lastAttempt: new Date().toISOString(),\n        attempts: item.attempts + 1\n      });\n\n      const result = await sendToBackend(item.payload, { \n        retryAttempt: item.attempts \n      });\n\n      if (result.success) {\n        QueueStorage.remove(item.id);\n        console.info('Queued submission delivered', item.id);\n      } else if (!result.retryable) {\n        logError('Non-retryable error, dropping item', { \n          item, \n          error: result.error \n        });\n        QueueStorage.remove(item.id);\n      } else {\n        // Update for next retry\n        QueueStorage.update(item.id, { \n          status: 'pending',\n          error: result.error.message\n        });\n      }\n\n    } catch (error) {\n      logError('Error processing queue item', { error, item });\n      QueueStorage.update(item.id, { \n        status: 'pending',\n        error: error.message \n      });\n    }\n  }\n}\n\n// Enhanced queue starter with network status handling\n// Clean up old queue items periodically\nfunction cleanupQueue() {\n  const queue = QueueStorage.read();\n  const now = Date.now();\n  const maxAge = 7 * 24 * 60 * 60 * 1000; // 7 days\n\n  const filtered = queue.filter(item => {\n    const age = now - new Date(item.createdAt).getTime();\n    return age < maxAge;\n  });\n\n  if (filtered.length < queue.length) {\n    logError('Cleaned up old queue items', { \n      removed: queue.length - filtered.length \n    });\n    QueueStorage.write(filtered);\n  }\n}\n\nexport function startSubmissionQueue({ intervalMs = 30000 } = {}) {\n  if (processorStarted) return;\n  processorStarted = true;\n\n  // Add periodic queue cleanup\n  setInterval(cleanupQueue, CLEANUP_INTERVAL);\n\n  // Monitor network status\n  window.addEventListener('online', () => {\n    onlineStatus = true;\n    processQueueOnce().catch(error => \n      logError('Queue process failed on online', { error })\n    );\n  });\n\n  window.addEventListener('offline', () => {\n    onlineStatus = false;\n  });\n\n  // Initial process\n  setTimeout(() => {\n    processQueueOnce().catch(error => \n      logError('Initial queue process failed', { error })\n    );\n  }, 2000);\n\n  // Periodic retry\n  setInterval(() => {\n    if (onlineStatus) {\n      processQueueOnce().catch(error => \n        logError('Queue retry failed', { error })\n      );\n    }\n  }, intervalMs);\n\n  // Process on visibility change\n  document.addEventListener('visibilitychange', () => {\n    if (document.visibilityState === 'visible' && onlineStatus) {\n      processQueueOnce().catch(() => {});\n    }\n  });\n}\n\n// Queue status helpers\nexport function getQueueStatus() {\n  const queue = QueueStorage.read();\n  return {\n    length: queue.length,\n    oldestAttempt: queue.length ? \n      new Date(queue[0].createdAt).getTime() : \n      null,\n    processing: queue.filter(i => i.status === 'processing').length,\n    failed: queue.filter(i => i.attempts >= MAX_RETRIES).length\n  };\n}\n\n// Debug helpers\nexport function _clearQueue() {\n  if (process.env.NODE_ENV !== 'production') {\n    QueueStorage.write([]);\n  }\n}\n\nexport default {\n  enqueueSubmission,\n  startSubmissionQueue,\n  getQueueStatus,\n  subscribeToQueueStatus,\n  _clearQueue\n};\n"],"names":["STORAGE_KEY","MAX_BACKOFF","MAX_PAYLOAD_SIZE","RETRYABLE_STATUS_CODES","Set","processorStarted","onlineStatus","navigator","onLine","subscribers","subscribeToQueueStatus","callback","add","delete","QueueStorage","read","raw","localStorage","getItem","data","JSON","parse","Array","isArray","error","logError","write","queue","setItem","stringify","status","queueLength","length","forEach","keys","Object","slice","key","removeItem","e","push","item","this","splice","payloadSize","TextEncoder","encode","payload","size","limit","id","Error","remove","filter","i","update","updates","index","findIndex","calculateBackoff","attempts","base","Math","min","pow","jitter","random","async","sendToBackend","timeout","retryAttempt","endpoint","__vite_import_meta_env__","VITE_API_BASE","define_process_env_default","window","__RUNTIME_CONFIG__","API_BASE","replace","URL","location","origin","getApiEndpoint","controller","AbortController","timeoutId","setTimeout","abort","res","fetch","method","headers","toString","body","signal","clearTimeout","ok","text","catch","success","json","isTimeout","name","isNetwork","message","includes","isRetryableStatus","has","isConnectionIssue","isSecurityIssue","retryable","enqueueSubmission","Date","now","envelope","createdAt","toISOString","result","sent","startSubmissionQueue","queued","queuedId","processQueueOnce","backoff","lastAttempt","getTime","cleanupQueue","filtered","removed","intervalMs","setInterval","addEventListener","document","visibilityState","getQueueStatus","oldestAttempt","processing","failed","_clearQueue","submitQueue"],"mappings":"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"}